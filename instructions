charger le firmware dans un dual core : 
- faire le load du SoC : "./build_platform.py (--build) --load"
- build le firmware : "./build_firmware.py --make_clean"
- faire un litex_term par coeur, donner en paramètre l'image indiquant dans quelle partie de la mémoire (interne au coeur (sram) ou externe (sp)) la charger :
"./litex_term.py /dev/ttyUSBx --images=/home/jamorin/InnovR/AES_SVM_On_AMP_joseph/firmwares/config_1_8/core_0_firmware/boot.json"

application pour mesurer le temps d'exécution d'une appli dasn AES_.../amp_lib/.../amp_utils.h/c fonctions amp_millis


pour enregistrer les mesures du smartpower : 
minicom -s : configurer le port série (ttyUSBx)
minicom : lance la liaison
ctr-A puis Z : permet de choisir le lancement de l'enregistrement dans un fichier


Pour utiliser la Gapuino : 
faire GAP_SDK et choisir la GAPUINO_V3
aller dans le dossier contenant le makefile du projet et faire make clean all pour envoyer le programme dans la carte, make run pour le lancer
ATTENTION les clean de gap supriment aussi les librairies et includes rajoutés à la main ! J'ai commenté la ligne qui fait ça pulp_rules.mk (à la toute fin, def du clean) mais je ne suis pas absolument sûr que ça résolve tout/ne pose pas problème
